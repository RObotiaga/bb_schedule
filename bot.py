import asyncio
import logging
import json
import os
import re
import sys
import sqlite3
from datetime import date, timedelta
from typing import List

from aiogram import Bot, Dispatcher, F, types
from aiogram.filters import CommandStart, BaseFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.filters.callback_data import CallbackData

# --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
DB_PATH = "data/schedule.db"

admin_id_str = os.getenv("ADMIN_ID")
if not admin_id_str:
    logging.error("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: ADMIN_ID –Ω–µ –∑–∞–¥–∞–Ω!")
    sys.exit(1)

try:
    ADMIN_ID = int(admin_id_str)
except ValueError:
    logging.error(f"–û—à–∏–±–∫–∞: ADMIN_ID '{admin_id_str}' –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —á–∏—Å–ª–æ–º!")
    sys.exit(1)

# --- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ---
structured_data = {}
FACULTIES_LIST = []
ALL_TEACHERS_LIST = [] # <-- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ù–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ –¥–ª—è –≤—Å–µ—Ö –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π

# --- –§–∞–±—Ä–∏–∫–∞ –¥–ª—è –∫–æ–ª–±–µ–∫–æ–≤ –∫—É—Ä—Å–æ–≤ ---
class CourseCallbackFactory(CallbackData, prefix="course"):
    course_id: int
    faculty_id: int

# --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö ---
def get_db_connection():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn

def load_structure_from_db():
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –º–µ–Ω—é –ò —Å–ø–∏—Å–æ–∫ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π –∏–∑ –ë–î."""
    global structured_data, FACULTIES_LIST, ALL_TEACHERS_LIST
    if not os.path.exists(DB_PATH):
        logging.error(f"–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö '{DB_PATH}' –Ω–µ –Ω–∞–π–¥–µ–Ω–∞! –ó–∞–ø—É—Å—Ç–∏—Ç–µ process_schedules.py.")
        return False
    
    conn = get_db_connection()
    cursor = conn.cursor()
    
    # –ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
    cursor.execute("SELECT DISTINCT faculty, course, group_name FROM schedule ORDER BY faculty, course, group_name")
    rows = cursor.fetchall()
    temp_structured_data = {}
    for row in rows:
        faculty, course, group_name = row['faculty'], row['course'], row['group_name']
        if faculty not in temp_structured_data: temp_structured_data[faculty] = {}
        if course not in temp_structured_data[faculty]: temp_structured_data[faculty][course] = []
        if group_name not in temp_structured_data[faculty][course]: temp_structured_data[faculty][course].append(group_name)
    structured_data = temp_structured_data
    FACULTIES_LIST = sorted(structured_data.keys())
    
    # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ó–∞–≥—Ä—É–∑–∫–∞ —Å–ø–∏—Å–∫–∞ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π
    cursor.execute("SELECT DISTINCT teacher FROM schedule WHERE teacher != '–ù–µ —É–∫–∞–∑–∞–Ω'")
    ALL_TEACHERS_LIST = sorted([row['teacher'] for row in cursor.fetchall()])
    
    conn.close()
    logging.info(f"–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–µ–Ω—é –∏ {len(ALL_TEACHERS_LIST)} –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ –ë–î.")
    return True

def init_user_db():
    conn = get_db_connection()
    conn.execute("CREATE TABLE IF NOT EXISTS users (user_id INTEGER PRIMARY KEY, group_name TEXT)")
    conn.commit(); conn.close()

def save_user_group_db(user_id: int, group_name: str | None):
    conn = get_db_connection()
    conn.execute("INSERT OR REPLACE INTO users (user_id, group_name) VALUES (?, ?)", (user_id, group_name))
    conn.commit(); conn.close()

def get_user_group_db(user_id: int) -> str | None:
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT group_name FROM users WHERE user_id = ?", (user_id,))
    row = cursor.fetchone()
    conn.close()
    return row['group_name'] if row else None

# --- –ü–µ—Ä–≤–∏—á–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è ---
init_user_db()
load_structure_from_db()

# --- FSM, –§–∏–ª—å—Ç—Ä—ã, –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---
class TeacherSearch(StatesGroup): name, matches = State(), State()
class IsAdmin(BaseFilter):
    async def __call__(self, message: Message) -> bool: return message.from_user.id == ADMIN_ID

# ... (–≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏ get_*_keyboard –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å) ...
def get_faculties_keyboard():
    builder = InlineKeyboardBuilder()
    [builder.button(text=name, callback_data=f"faculty:{i}") for i, name in enumerate(FACULTIES_LIST)]; builder.adjust(2)
    return builder.as_markup()
def get_courses_keyboard(faculty_id: int):
    faculty = FACULTIES_LIST[faculty_id]
    builder = InlineKeyboardBuilder()
    courses = sorted(structured_data.get(faculty, {}).keys(), key=lambda c: int(c) if c.isdigit() else 99)
    for course in courses:
        builder.button(
            text=f"{course} –∫—É—Ä—Å",
            callback_data=CourseCallbackFactory(course_id=int(course), faculty_id=faculty_id)
        )
    builder.adjust(2)
    builder.row(InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞–º", callback_data="back_to_faculties"))
    return builder.as_markup()
def get_groups_keyboard(faculty: str, course: str):
    builder = InlineKeyboardBuilder()
    groups = sorted(structured_data.get(faculty, {}).get(course, []))
    [builder.button(text=g, callback_data=f"group:{g}") for g in groups]; builder.adjust(2)
    builder.row(InlineKeyboardButton(text=f"‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –∫—É—Ä—Å–∞–º ({faculty})", callback_data=f"back_to_courses:{FACULTIES_LIST.index(faculty)}"))
    return builder.as_markup()
def get_teacher_choices_keyboard(teachers: List[str]):
    builder = InlineKeyboardBuilder()
    [builder.button(text=name, callback_data=f"teacher_select:{i}") for i, name in enumerate(teachers)]; builder.adjust(1)
    return builder.as_markup()
def get_teacher_nav_keyboard(current_offset: int):
    builder = InlineKeyboardBuilder()
    builder.button(text="‚¨ÖÔ∏è –ü—Ä–µ–¥. –¥–µ–Ω—å", callback_data=f"teacher_nav:{current_offset - 1}")
    builder.button(text="–°–ª–µ–¥. –¥–µ–Ω—å ‚û°Ô∏è", callback_data=f"teacher_nav:{current_offset + 1}")
    return builder.as_markup()
day_selection_keyboard = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–°–µ–≥–æ–¥–Ω—è"), KeyboardButton(text="–ó–∞–≤—Ç—Ä–∞")], [KeyboardButton(text="–ü–Ω"), KeyboardButton(text="–í—Ç"), KeyboardButton(text="–°—Ä")], [KeyboardButton(text="–ß—Ç"), KeyboardButton(text="–ü—Ç"), KeyboardButton(text="–°–±")], [KeyboardButton(text="/start")]], resize_keyboard=True)
admin_keyboard = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ"), KeyboardButton(text="üì• –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É")], [KeyboardButton(text="‚¨ÖÔ∏è –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏")]], resize_keyboard=True)

# --- –•—ç–Ω–¥–ª–µ—Ä—ã ---
dp = Dispatcher(storage=MemoryStorage())

@dp.message(CommandStart())
async def send_welcome(message: Message):
    save_user_group_db(message.from_user.id, None)
    await message.answer("üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –Ø –ø–æ–º–æ–≥—É –≤–∞–º —É–∑–Ω–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ.\n\n"
                         "–î–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –≥—Ä—É–ø–ø–µ - –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —Ñ–∞–∫—É–ª—å—Ç–µ—Ç.\n"
                         "–î–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—é - –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ –µ–≥–æ —Ñ–∞–º–∏–ª–∏—é.",
                         reply_markup=get_faculties_keyboard())

# ... (—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ show_teacher_schedule –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å) ...
def format_schedule_message(group: str, target_date: date, lessons: List[sqlite3.Row]) -> str:
    months = ["–Ø–Ω–≤–∞—Ä—è", "–§–µ–≤—Ä–∞–ª—è", "–ú–∞—Ä—Ç–∞", "–ê–ø—Ä–µ–ª—è", "–ú–∞—è", "–ò—é–Ω—è", "–ò—é–ª—è", "–ê–≤–≥—É—Å—Ç–∞", "–°–µ–Ω—Ç—è–±—Ä—è", "–û–∫—Ç—è–±—Ä—è", "–ù–æ—è–±—Ä—è", "–î–µ–∫–∞–±—Ä—è"]
    weekdays = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    date_str = f"{weekdays[target_date.weekday()]} {target_date.day} {months[target_date.month - 1]}"
    if not lessons:
        week_number = target_date.isocalendar()[1]
        week_type = "–ß–µ—Ç–Ω–∞—è" if week_number % 2 == 0 else "–ù–µ—á–µ—Ç–Ω–∞—è"
        header = f"*{week_type} –Ω–µ–¥–µ–ª—è*\n*{group}*\n\n*{date_str}*"
        return f"{header}\n‚ùå–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç‚ùå"
    week_type = lessons[0]['week_type'].capitalize()
    header = f"*{week_type} –Ω–µ–¥–µ–ª—è*\n*{group}*\n\n*{date_str}*"
    lesson_parts = [f"‚è∞ {lesson['time']}\n-  `{lesson['subject']}`\n-  `{lesson['teacher']}`\n-  `{lesson['location']}`" for lesson in lessons]
    return f"{header}\n\n" + "\n\n".join(lesson_parts)

async def show_teacher_schedule(target: Message | CallbackQuery, teacher_name: str, day_offset: int):
    target_date = date.today() + timedelta(days=day_offset)
    date_str = target_date.strftime('%Y-%m-%d')
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM schedule WHERE teacher = ? AND lesson_date = ? ORDER BY time", (teacher_name, date_str))
    lessons_raw = cursor.fetchall()
    conn.close()
    merged_lessons = {}
    for lesson in lessons_raw:
        key = (lesson['time'], lesson['subject'], lesson['location'])
        if key not in merged_lessons:
            merged_lessons[key] = dict(lesson)
            merged_lessons[key]['groups'] = [lesson['group_name']]
        else:
            merged_lessons[key]['groups'].append(lesson['group_name'])
    lessons = list(merged_lessons.values())
    months = ["–Ø–Ω–≤–∞—Ä—è", "–§–µ–≤—Ä–∞–ª—è", "–ú–∞—Ä—Ç–∞", "–ê–ø—Ä–µ–ª—è", "–ú–∞—è", "–ò—é–Ω—è", "–ò—é–ª—è", "–ê–≤–≥—É—Å—Ç–∞", "–°–µ–Ω—Ç—è–±—Ä—è", "–û–∫—Ç—è–±—Ä—è", "–ù–æ—è–±—Ä—è", "–î–µ–∫–∞–±—Ä—è"]
    weekdays = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    date_formatted = f"{weekdays[target_date.weekday()]} {target_date.day} {months[target_date.month - 1]}"
    if not lessons:
        week_number = target_date.isocalendar()[1]
        week_type = "–ß–µ—Ç–Ω–∞—è" if week_number % 2 == 0 else "–ù–µ—á–µ—Ç–Ω–∞—è"
        header = f"*{week_type} –Ω–µ–¥–µ–ª—è*\n*{teacher_name}*\n\n*{date_formatted}*"
        text = f"{header}\n‚ùå–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç‚ùå"
    else:
        week_type = lessons[0]['week_type'].capitalize()
        header = f"*{week_type} –Ω–µ–¥–µ–ª—è*\n*{teacher_name}*\n\n*{date_formatted}*"
        lesson_parts = []
        for lesson in lessons:
            groups, group_prefix = lesson.get('groups', []), "—Å –≥—Ä—É–ø–ø–æ–π"
            if len(groups) > 1: group_prefix = "—Å –≥—Ä—É–ø–ø–∞–º–∏"
            groups_str = ", ".join(groups)
            part = f"‚è∞ {lesson['time']} {group_prefix} *{groups_str}*\n-  `{lesson['subject']}`\n-  `{lesson['location']}`"
            lesson_parts.append(part)
        text = f"{header}\n\n" + "\n\n".join(lesson_parts)
    keyboard = get_teacher_nav_keyboard(day_offset)
    if isinstance(target, Message):
        await target.answer(text, reply_markup=keyboard, parse_mode="Markdown")
    elif isinstance(target, CallbackQuery):
        if target.message.text != text: await target.message.edit_text(text, reply_markup=keyboard, parse_mode="Markdown")
        await target.answer()

# --- –•—ç–Ω–¥–ª–µ—Ä—ã –°—Ç—É–¥–µ–Ω—Ç–æ–≤ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---
@dp.callback_query(F.data.startswith("faculty:"))
async def process_faculty_choice(callback: CallbackQuery):
    faculty_id = int(callback.data.split(":")[1])
    faculty_name = FACULTIES_LIST[faculty_id]
    await callback.message.edit_text(
        f"–í—ã –≤—ã–±—Ä–∞–ª–∏: *{faculty_name}*.\n\n–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å:",
        reply_markup=get_courses_keyboard(faculty_id),
        parse_mode="Markdown"
    )
    await callback.answer()
@dp.callback_query(CourseCallbackFactory.filter())
async def process_course_choice(callback: CallbackQuery, callback_data: CourseCallbackFactory):
    course_id = callback_data.course_id
    faculty_id = callback_data.faculty_id
    faculty = FACULTIES_LIST[faculty_id]
    await callback.message.edit_text(
        f"–§–∞–∫—É–ª—å—Ç–µ—Ç: *{faculty}*, –ö—É—Ä—Å: *{course_id}*.\n\n–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à—É –≥—Ä—É–ø–ø—É:",
        reply_markup=get_groups_keyboard(faculty, str(course_id)),
        parse_mode="Markdown"
    )
    await callback.answer()
@dp.callback_query(F.data.startswith("group:"))
async def process_group_choice(callback: CallbackQuery):
    group = callback.data.split(":")[1]
    save_user_group_db(callback.from_user.id, group)
    await callback.message.delete()
    await callback.message.answer(f"–û—Ç–ª–∏—á–Ω–æ! –í–∞—à–∞ –≥—Ä—É–ø–ø–∞ *{group}* —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.", reply_markup=day_selection_keyboard, parse_mode="Markdown")
    await callback.answer()
@dp.callback_query(F.data == "back_to_faculties")
async def back_to_faculties(callback: CallbackQuery):
    await callback.message.edit_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —Ñ–∞–∫—É–ª—å—Ç–µ—Ç:", reply_markup=get_faculties_keyboard())
    await callback.answer()
@dp.callback_query(F.data.startswith("back_to_courses:"))
async def back_to_courses(callback: CallbackQuery):
    faculty_id = int(callback.data.split(":")[1])
    faculty_name = FACULTIES_LIST[faculty_id]
    await callback.message.edit_text(
        f"–í—ã –≤—ã–±—Ä–∞–ª–∏: *{faculty_name}*.\n\n–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å:",
        reply_markup=get_courses_keyboard(faculty_id),
        parse_mode="Markdown"
    )
    await callback.answer()
def get_date_by_day_name(day_name: str) -> date:
    today = date.today()
    if day_name == "–°–µ–≥–æ–¥–Ω—è": return today
    if day_name == "–ó–∞–≤—Ç—Ä–∞": return today + timedelta(days=1)
    days_map = {"–ü–Ω": 0, "–í—Ç": 1, "–°—Ä": 2, "–ß—Ç": 3, "–ü—Ç": 4, "–°–±": 5}
    target_weekday = days_map[day_name]
    days_ahead = target_weekday - today.weekday()
    if days_ahead < 0: days_ahead += 7
    return today + timedelta(days_ahead)
@dp.message(F.text.in_({"–°–µ–≥–æ–¥–Ω—è", "–ó–∞–≤—Ç—Ä–∞", "–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±"}))
async def send_schedule(message: Message):
    group = get_user_group_db(message.from_user.id)
    if not group: await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É /start"); return
    try:
        target_date = get_date_by_day_name(message.text)
        date_str = target_date.strftime('%Y-%m-%d')
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM schedule WHERE group_name = ? AND lesson_date = ? ORDER BY time", (group, date_str))
        lessons = cursor.fetchall()
        conn.close()
        response_text = format_schedule_message(group, target_date, lessons)
        await message.answer(response_text, parse_mode="Markdown")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}"); await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞.")

# --- –•—ç–Ω–¥–ª–µ—Ä—ã –ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π ---
@dp.callback_query(F.data.startswith("teacher_select:"))
async def process_teacher_selection(callback: CallbackQuery, state: FSMContext):
    selection_index = int(callback.data.split(":")[1])
    data = await state.get_data(); teacher_matches = data.get('matches', [])
    if selection_index >= len(teacher_matches):
        await callback.message.edit_text("–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."); return
    selected_teacher = teacher_matches[selection_index]
    await state.update_data(name=selected_teacher)
    await show_teacher_schedule(callback, selected_teacher, 0)

@dp.callback_query(F.data.startswith("teacher_nav:"))
async def navigate_teacher_schedule(callback: CallbackQuery, state: FSMContext):
    day_offset = int(callback.data.split(":")[1])
    data = await state.get_data(); teacher_name = data.get('name')
    if not teacher_name:
        await callback.message.edit_text("–í–∞—à –≤—ã–±–æ—Ä –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –∏—Å—Ç–µ–∫. –ù–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ."); return
    await show_teacher_schedule(callback, teacher_name, day_offset)

KNOWN_BUTTONS = {"–°–µ–≥–æ–¥–Ω—è", "–ó–∞–≤—Ç—Ä–∞", "–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ", "üì• –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É", "‚¨ÖÔ∏è –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏"}
@dp.message(F.text, ~F.text.in_(KNOWN_BUTTONS), ~F.text.startswith('/'))
async def find_teacher_by_name(message: Message, state: FSMContext):
    """–ò—â–µ—Ç –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –ø–æ —Ñ–∞–º–∏–ª–∏–∏ –≤ —Å–ø–∏—Å–∫–µ, –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–º –≤ –ø–∞–º—è—Ç—å."""
    await state.clear()
    search_query = message.text.strip().lower()
    
    # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ü–æ–∏—Å–∫ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –≤ Python-—Å–ø–∏—Å–∫–µ, –∞ –Ω–µ –≤ –ë–î
    matches = [name for name in ALL_TEACHERS_LIST if search_query in name.lower()]
    
    if not matches:
        await message.answer("üòï –ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."); return
    if len(matches) == 1:
        await state.update_data(name=matches[0])
        await show_teacher_schedule(message, matches[0], 0); return
        
    await state.update_data(matches=matches)
    await message.answer("–ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ:", reply_markup=get_teacher_choices_keyboard(matches))

# --- –•—ç–Ω–¥–ª–µ—Ä—ã –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ---
@dp.message(F.text == "/admin", IsAdmin())
async def admin_panel(message: Message):
    await message.answer("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å!", reply_markup=admin_keyboard)

@dp.message(F.text == "‚¨ÖÔ∏è –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏", IsAdmin())
async def exit_admin_panel(message: Message):
    await message.answer("–í—ã –≤—ã—à–ª–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.", reply_markup=day_selection_keyboard)

async def run_script(command: list, message: Message):
    process = await asyncio.create_subprocess_exec(*command, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
    stdout, stderr = await process.communicate()
    if process.returncode != 0:
        error_message = f"‚ùå –û—à–∏–±–∫–∞ `{command[-1]}`:\n`{stderr.decode('utf-8', errors='ignore')}`"
        await message.answer(error_message[:4096], parse_mode="Markdown"); return False
    return True

@dp.message(F.text == "üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ", IsAdmin())
async def update_schedule(message: Message):
    await message.answer("üöÄ –ù–∞—á–∏–Ω–∞—é –ø–æ–ª–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ...", reply_markup=types.ReplyKeyboardRemove())
    python_executable = sys.executable
    if await run_script([python_executable, "fetch_schedule.py"], message) and \
       await run_script([python_executable, "process_schedules.py"], message) and \
       load_structure_from_db(): # <-- –í–ê–ñ–ù–û: –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
        await message.answer("‚úÖ –ü–æ–ª–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!", reply_markup=admin_keyboard)
    else:
        await message.answer("‚ùóÔ∏è–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ—Ä–≤–∞–Ω–æ –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏.", reply_markup=admin_keyboard)

@dp.message(F.text == "üì• –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É", IsAdmin())
async def reload_from_db(message: Message):
    if load_structure_from_db():
        await message.answer("‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–µ–Ω—é –∏ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –∏–∑ –ë–î!", reply_markup=admin_keyboard)
    else:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É.", reply_markup=admin_keyboard)

# --- –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ ---
async def main():
    bot = Bot(token=BOT_TOKEN)
    await dp.start_polling(bot)

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    asyncio.run(main())