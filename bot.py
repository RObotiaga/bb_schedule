import asyncio
import logging
import json
import os
import re
import sys
from datetime import date, timedelta
from typing import List

from aiogram import Bot, Dispatcher, F, types
from aiogram.filters import CommandStart, BaseFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder

# --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", 'placeholder:TELEGRAM_TOKEN_REMOVED')
SCHEDULE_JSON_PATH = "schedule.json"
ADMIN_ID = 936853523
USER_DATA_JSON_PATH = "user_data.json"

# --- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ ---
full_schedule = {}
teacher_schedule = {} # <-- –î–ª—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π
structured_data = {}
FACULTIES_LIST = []
user_choices = {}

# --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏ ---
def load_and_prepare_data():
    global full_schedule, teacher_schedule, structured_data, FACULTIES_LIST
    if not os.path.exists(SCHEDULE_JSON_PATH):
        logging.warning(f"–§–∞–π–ª '{SCHEDULE_JSON_PATH}' –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return False
    try:
        with open(SCHEDULE_JSON_PATH, 'r', encoding='utf-8') as f:
            data = json.load(f)
            # --- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ó–∞–≥—Ä—É–∂–∞–µ–º –æ–±–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã ---
            full_schedule = data.get("student_schedule", {})
            teacher_schedule = data.get("teacher_schedule", {})
    except json.JSONDecodeError:
        logging.error(f"–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON –≤ {SCHEDULE_JSON_PATH}."); return False
    
    # ... (–æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
    temp_structured_data = {}
    for group_name, group_sch in full_schedule.items():
        if not group_sch: continue
        try:
            first_date = next(iter(group_sch))
            first_lesson = group_sch[first_date][0]
            faculty, course = first_lesson['faculty'], first_lesson['course']
            if faculty not in temp_structured_data: temp_structured_data[faculty] = {}
            if course not in temp_structured_data[faculty]: temp_structured_data[faculty][course] = []
            if group_name not in temp_structured_data[faculty][course]: temp_structured_data[faculty][course].append(group_name)
        except (StopIteration, IndexError, KeyError) as e:
            logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≥—Ä—É–ø–ø—É '{group_name}'. –û—à–∏–±–∫–∞: {e}")
    structured_data = temp_structured_data
    FACULTIES_LIST = sorted(structured_data.keys())
    logging.info("–î–∞–Ω–Ω—ã–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.")
    return True

# ... (—Ñ—É–Ω–∫—Ü–∏–∏ load_user_data, save_user_data, get_user_group –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å) ...
def load_user_data():
    global user_choices
    if os.path.exists(USER_DATA_JSON_PATH):
        try:
            with open(USER_DATA_JSON_PATH, 'r', encoding='utf-8') as f:
                user_choices = json.load(f)
                user_choices = {int(k): v for k, v in user_choices.items()}
        except (json.JSONDecodeError, TypeError):
            logging.error("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è user_data.json. –ë—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π.")
            user_choices = {}
    else: user_choices = {}
    logging.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(user_choices)} –∑–∞–ø–∏—Å–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")

def save_user_data(user_id: int, group: str | None):
    if group is None: user_choices.pop(user_id, None)
    else: user_choices[user_id] = group
    with open(USER_DATA_JSON_PATH, 'w', encoding='utf-8') as f:
        json.dump(user_choices, f, ensure_ascii=False, indent=4)

def get_user_group(user_id: int) -> str | None:
    return user_choices.get(user_id)


load_and_prepare_data()
load_user_data()

# --- FSM –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è ---
class TeacherSearch(StatesGroup):
    name = State()
    matches = State()

# --- –§–∏–ª—å—Ç—Ä –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ ---
class IsAdmin(BaseFilter):
    async def __call__(self, message: Message) -> bool:
        return message.from_user.id == ADMIN_ID

# --- –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---
# ... (get_faculties_keyboard, get_courses_keyboard, get_groups_keyboard –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å) ...
def get_faculties_keyboard():
    builder = InlineKeyboardBuilder()
    for index, faculty_name in enumerate(FACULTIES_LIST):
        builder.button(text=faculty_name, callback_data=f"faculty:{index}")
    builder.adjust(2)
    return builder.as_markup()

def get_courses_keyboard(faculty: str):
    builder = InlineKeyboardBuilder()
    courses = sorted(structured_data.get(faculty, {}).keys(), key=lambda c: int(c) if c.isdigit() else 99)
    for course in courses:
        builder.button(text=f"{course} –∫—É—Ä—Å", callback_data=f"course:{faculty}:{course}")
    builder.adjust(2)
    builder.row(InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞–º", callback_data="back_to_faculties"))
    return builder.as_markup()

def get_groups_keyboard(faculty: str, course: str):
    builder = InlineKeyboardBuilder()
    groups = sorted(structured_data.get(faculty, {}).get(course, []))
    for group in groups:
        builder.button(text=group, callback_data=f"group:{group}")
    builder.adjust(2)
    faculty_index = FACULTIES_LIST.index(faculty)
    builder.row(InlineKeyboardButton(text=f"‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –∫—É—Ä—Å–∞–º ({faculty})", callback_data=f"back_to_courses:{faculty_index}"))
    return builder.as_markup()


# --- –ù–û–í–´–ï –ö–õ–ê–í–ò–ê–¢–£–†–´ –î–õ–Ø –ü–†–ï–ü–û–î–ê–í–ê–¢–ï–õ–ï–ô ---
def get_teacher_choices_keyboard(teachers: List[str]):
    builder = InlineKeyboardBuilder()
    for index, name in enumerate(teachers):
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω–¥–µ–∫—Å, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–∫–∏ —Å –¥–ª–∏–Ω–Ω—ã–º–∏ callback_data
        builder.button(text=name, callback_data=f"teacher_select:{index}")
    builder.adjust(1)
    return builder.as_markup()

def get_teacher_nav_keyboard(current_offset: int):
    builder = InlineKeyboardBuilder()
    builder.button(text="‚¨ÖÔ∏è –ü—Ä–µ–¥. –¥–µ–Ω—å", callback_data=f"teacher_nav:{current_offset - 1}")
    builder.button(text="–°–ª–µ–¥. –¥–µ–Ω—å ‚û°Ô∏è", callback_data=f"teacher_nav:{current_offset + 1}")
    return builder.as_markup()

# ... (day_selection_keyboard, admin_keyboard –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å) ...
day_selection_keyboard = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–°–µ–≥–æ–¥–Ω—è"), KeyboardButton(text="–ó–∞–≤—Ç—Ä–∞")], [KeyboardButton(text="–ü–Ω"), KeyboardButton(text="–í—Ç"), KeyboardButton(text="–°—Ä")], [KeyboardButton(text="–ß—Ç"), KeyboardButton(text="–ü—Ç"), KeyboardButton(text="–°–±")]], resize_keyboard=True)
admin_keyboard = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ"), KeyboardButton(text="üì• –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å JSON")], [KeyboardButton(text="‚¨ÖÔ∏è –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏")]], resize_keyboard=True)


# --- –•—ç–Ω–¥–ª–µ—Ä—ã ---
dp = Dispatcher(storage=MemoryStorage()) # FSM —Ç—Ä–µ–±—É–µ—Ç —Ö—Ä–∞–Ω–∏–ª–∏—â–µ

# ... (—Ö—ç–Ω–¥–ª–µ—Ä—ã /start, admin, callback-–∏ –≤—ã–±–æ—Ä–∞ –≥—Ä—É–ø–ø—ã –∏ —Ç.–¥. –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å) ...
# (–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –¥–ª—è –ø–æ–ª–Ω–æ—Ç—ã)
@dp.message(CommandStart())
async def send_welcome(message: Message):
    save_user_data(message.from_user.id, None)
    await message.answer("üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –Ø –ø–æ–º–æ–≥—É –≤–∞–º —É–∑–Ω–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ.\n\n"
                         "–î–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –≥—Ä—É–ø–ø–µ - –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —Ñ–∞–∫—É–ª—å—Ç–µ—Ç.\n"
                         "–î–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—é - –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ –µ–≥–æ —Ñ–∞–º–∏–ª–∏—é.",
                         reply_markup=get_faculties_keyboard())

# --- –ù–û–í–´–ï –•–≠–ù–î–õ–ï–†–´ –î–õ–Ø –ü–û–ò–°–ö–ê –ü–†–ï–ü–û–î–ê–í–ê–¢–ï–õ–Ø ---
# --- –ó–ê–ú–ï–ù–ò–¢–ï –≠–¢–£ –§–£–ù–ö–¶–ò–Æ –≤ bot.py ---
async def show_teacher_schedule(target: Message | CallbackQuery, teacher_name: str, day_offset: int, state: FSMContext):
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è.
    –° –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∞ –∏ –≥—Ä–∞–º–æ—Ç–Ω—ã–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –≥—Ä—É–ø–ø.
    """
    target_date = date.today() + timedelta(days=day_offset)
    date_str = target_date.strftime('%Y-%m-%d')
    lessons = teacher_schedule.get(teacher_name, {}).get(date_str, [])
    
    months = ["–Ø–Ω–≤–∞—Ä—è", "–§–µ–≤—Ä–∞–ª—è", "–ú–∞—Ä—Ç–∞", "–ê–ø—Ä–µ–ª—è", "–ú–∞—è", "–ò—é–Ω—è", "–ò—é–ª—è", "–ê–≤–≥—É—Å—Ç–∞", "–°–µ–Ω—Ç—è–±—Ä—è", "–û–∫—Ç—è–±—Ä—è", "–ù–æ—è–±—Ä—è", "–î–µ–∫–∞–±—Ä—è"]
    weekdays = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    date_formatted = f"{weekdays[target_date.weekday()]} {target_date.day} {months[target_date.month - 1]}"

    if not lessons:
        week_number = target_date.isocalendar()[1]
        week_type = "–ß–µ—Ç–Ω–∞—è" if week_number % 2 == 0 else "–ù–µ—á–µ—Ç–Ω–∞—è"
        # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ –∂–∏—Ä–Ω—ã–π
        header = f"*{week_type} –Ω–µ–¥–µ–ª—è*\n*{teacher_name}*\n\n*{date_formatted}*"
        text = f"{header}\n‚ùå–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç‚ùå"
    else:
        week_type = lessons[0]['week_type'].capitalize()
        # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ –∂–∏—Ä–Ω—ã–π
        header = f"*{week_type} –Ω–µ–¥–µ–ª—è*\n*{teacher_name}*\n\n*{date_formatted}*"
        lesson_parts = []
        for lesson in lessons:
            # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –õ–æ–≥–∏–∫–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ "–≥—Ä—É–ø–ø–æ–π" –∏–ª–∏ "–≥—Ä—É–ø–ø–∞–º–∏"
            groups = lesson.get('group', [])
            group_prefix = "—Å –≥—Ä—É–ø–ø–æ–π" if len(groups) == 1 else "—Å –≥—Ä—É–ø–ø–∞–º–∏"
            groups_str = ", ".join(groups)
            
            part = (
                f"‚è∞ {lesson['time']} {group_prefix} *{groups_str}*\n"
                f"-  `{lesson['subject']}`\n"
                f"-  `{lesson['location']}`"
            )
            lesson_parts.append(part)
        text = f"{header}\n\n" + "\n\n".join(lesson_parts)

    keyboard = get_teacher_nav_keyboard(day_offset)
    if isinstance(target, Message):
        await target.answer(text, reply_markup=keyboard, parse_mode="Markdown")
    elif isinstance(target, CallbackQuery):
        if target.message.text != text:
            await target.message.edit_text(text, reply_markup=keyboard, parse_mode="Markdown")
        await target.answer()

@dp.callback_query(F.data.startswith("teacher_select:"))
async def process_teacher_selection(callback: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –∏–∑ —Å–ø–∏—Å–∫–∞."""
    selection_index = int(callback.data.split(":")[1])
    data = await state.get_data()
    teacher_matches = data.get('matches', [])
    
    if selection_index >= len(teacher_matches):
        await callback.message.edit_text("–û—à–∏–±–∫–∞ –≤—ã–±–æ—Ä–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.")
        return

    selected_teacher = teacher_matches[selection_index]
    await state.update_data(name=selected_teacher) # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –≤ FSM
    
    await show_teacher_schedule(callback, selected_teacher, 0, state)

@dp.callback_query(F.data.startswith("teacher_nav:"))
async def navigate_teacher_schedule(callback: CallbackQuery, state: FSMContext):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–≤–∏–≥–∞—Ü–∏—é –ø–æ –¥–Ω—è–º –¥–ª—è –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è."""
    day_offset = int(callback.data.split(":")[1])
    data = await state.get_data()
    teacher_name = data.get('name')
    if not teacher_name:
        await callback.message.edit_text("–í–∞—à –≤—ã–±–æ—Ä –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –∏—Å—Ç–µ–∫. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –ø–æ–∏—Å–∫ –∑–∞–Ω–æ–≤–æ.")
        return
        
    await show_teacher_schedule(callback, teacher_name, day_offset, state)

@dp.message(F.text == "/admin", IsAdmin())
async def admin_panel(message: Message):
    """–û—Ç–∫—Ä—ã–≤–∞–µ—Ç –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞."""
    await message.answer("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å!", reply_markup=admin_keyboard)

@dp.message(F.text == "‚¨ÖÔ∏è –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏", IsAdmin())
async def exit_admin_panel(message: Message):
    """–í—ã—Ö–æ–¥ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏."""
    await message.answer("–í—ã –≤—ã—à–ª–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.", reply_markup=day_selection_keyboard)

async def run_script(command: list, message: Message):
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∑–∞–ø—É—Å–∫–∞–µ—Ç –≤–Ω–µ—à–Ω–∏–π —Å–∫—Ä–∏–ø—Ç –∏ —Å–æ–æ–±—â–∞–µ—Ç –æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ."""
    process = await asyncio.create_subprocess_exec(
        *command,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    stdout, stderr = await process.communicate()
    
    if process.returncode != 0:
        error_message = (
            f"‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–∫—Ä–∏–ø—Ç–∞ `{command[-1]}` (–∫–æ–¥: {process.returncode}):\n"
            f"```\n{stderr.decode('utf-8', errors='ignore')}\n```"
        )
        await message.answer(error_message[:4096], parse_mode="Markdown") # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É —Å–æ–æ–±—â–µ–Ω–∏—è
        return False
    return True

@dp.message(F.text == "üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ", IsAdmin())
async def update_schedule(message: Message):
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è."""
    await message.answer("üöÄ –ù–∞—á–∏–Ω–∞—é –ø–æ–ª–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è...", reply_markup=types.ReplyKeyboardRemove())
    python_executable = sys.executable
    
    if await run_script([python_executable, "fetch_schedule.py"], message) and \
       await run_script([python_executable, "process_schedules.py"], message) and \
       load_and_prepare_data():
        await message.answer("‚úÖ –ü–æ–ª–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!", reply_markup=admin_keyboard)
    else:
        await message.answer("‚ùóÔ∏è–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ—Ä–≤–∞–Ω–æ –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏.", reply_markup=admin_keyboard)

@dp.message(F.text == "üì• –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å JSON", IsAdmin())
async def reload_from_json(message: Message):
    """–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –∏–∑ JSON —Ñ–∞–π–ª–∞."""
    await message.answer("–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞—é –¥–∞–Ω–Ω—ã–µ –∏–∑ `schedule.json`...", parse_mode="Markdown")
    if load_and_prepare_data():
        await message.answer("‚úÖ –î–∞–Ω–Ω—ã–µ –≤ –±–æ—Ç–µ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã!", reply_markup=admin_keyboard)
    else:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.", reply_markup=admin_keyboard)

# –≠—Ç–æ—Ç —Ö—ç–Ω–¥–ª–µ—Ä –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–¥–Ω–∏–º –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö, —Ç.–∫. –æ–Ω "–ª–æ–≤–∏—Ç" –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç
KNOWN_BUTTONS = {"–°–µ–≥–æ–¥–Ω—è", "–ó–∞–≤—Ç—Ä–∞", "–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±",
                 "üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ", "üì• –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å JSON", "‚¨ÖÔ∏è –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏"}
@dp.message(F.text, ~F.text.in_(KNOWN_BUTTONS), ~F.text.startswith('/'))
async def find_teacher_by_name(message: Message, state: FSMContext):
    """–ò—â–µ—Ç –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –ø–æ —Ñ–∞–º–∏–ª–∏–∏."""
    await state.clear() # –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –ø–æ–∏—Å–∫
    search_query = message.text.strip().lower()
    
    # –ò—â–µ–º –≤—Å–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –ø–æ —Ñ–∞–º–∏–ª–∏–∏
    matches = [name for name in teacher_schedule.keys() if search_query in name.lower()]
    
    if not matches:
        await message.answer("üòï –ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–æ–π —Ñ–∞–º–∏–ª–∏–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
        return
        
    if len(matches) == 1:
        teacher_name = matches[0]
        await state.update_data(name=teacher_name)
        await show_teacher_schedule(message, teacher_name, 0, state)
        return

    # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ, –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –≤—ã–±—Ä–∞—Ç—å
    await state.update_data(matches=matches) # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö
    await message.answer(
        "–ù–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω–æ–≥–æ:",
        reply_markup=get_teacher_choices_keyboard(matches)
    )

# ... (—Å—Ç–∞—Ä—ã–µ —Ö—ç–Ω–¥–ª–µ—Ä—ã –¥–ª—è —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è —Å—Ç—É–¥–µ–Ω—Ç–æ–≤) ...
# (–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –¥–ª—è –ø–æ–ª–Ω–æ—Ç—ã)
@dp.message(F.text.in_({"–°–µ–≥–æ–¥–Ω—è", "–ó–∞–≤—Ç—Ä–∞", "–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±"}))
async def send_schedule(message: Message):
    group = get_user_group(message.from_user.id)
    if not group:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /start")
        return
    try:
        target_date = get_date_by_day_name(message.text)
        date_str = target_date.strftime('%Y-%m-%d')
        lessons = full_schedule.get(group, {}).get(date_str, [])
        response_text = format_schedule_message(group, target_date, lessons)
        await message.answer(response_text, parse_mode="Markdown")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞.")

def get_date_by_day_name(day_name: str) -> date:
    today = date.today()
    if day_name == "–°–µ–≥–æ–¥–Ω—è": return today
    if day_name == "–ó–∞–≤—Ç—Ä–∞": return today + timedelta(days=1)
    days_map = {"–ü–Ω": 0, "–í—Ç": 1, "–°—Ä": 2, "–ß—Ç": 3, "–ü—Ç": 4, "–°–±": 5}
    target_weekday = days_map[day_name]
    days_ahead = target_weekday - today.weekday()
    if days_ahead < 0: days_ahead += 7
    return today + timedelta(days=days_ahead)

def format_schedule_message(group: str, target_date: date, lessons: list) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ–º –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–∞ —Å –∫–æ–ø–∏—Ä—É–µ–º—ã–º–∏ —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏."""
    months = ["–Ø–Ω–≤–∞—Ä—è", "–§–µ–≤—Ä–∞–ª—è", "–ú–∞—Ä—Ç–∞", "–ê–ø—Ä–µ–ª—è", "–ú–∞—è", "–ò—é–Ω—è", "–ò—é–ª—è", "–ê–≤–≥—É—Å—Ç–∞", "–°–µ–Ω—Ç—è–±—Ä—è", "–û–∫—Ç—è–±—Ä—è", "–ù–æ—è–±—Ä—è", "–î–µ–∫–∞–±—Ä—è"]
    weekdays = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    date_str = f"{weekdays[target_date.weekday()]} {target_date.day} {months[target_date.month - 1]}"

    if not lessons:
        week_number = target_date.isocalendar()[1]
        week_type = "–ß–µ—Ç–Ω–∞—è" if week_number % 2 == 0 else "–ù–µ—á–µ—Ç–Ω–∞—è"
        header = f"*{week_type} –Ω–µ–¥–µ–ª—è*\n*{group}*\n\n*{date_str}*"
        return f"{header}\n‚ùå–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç‚ùå"
    
    week_type = lessons[0]['week_type'].capitalize()
    header = f"*{week_type} –Ω–µ–¥–µ–ª—è*\n*{group}*\n\n*{date_str}*"
    
    lesson_parts = []
    for lesson in lessons:
        # –ò–ó–ú–ï–ù–ï–ù–ò–ï: –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –Ω—É–∂–Ω—ã–µ —á–∞—Å—Ç–∏ –≤ `...`
        part = (
            f"‚è∞ {lesson['time']}\n"
            f"-  `{lesson['subject']}`\n"
            f"-  `{lesson['teacher']}`\n"
            f"-  `{lesson['location']}`"
        )
        lesson_parts.append(part)
        
    return f"{header}\n\n" + "\n\n".join(lesson_parts)

# --- –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ ---
async def main():
    bot = Bot(token=BOT_TOKEN)
    await dp.start_polling(bot)

if __name__ == '__main__':
    # ... (—Å—Ç–∞—Ä—ã–π –∫–æ–¥, –æ—Å—Ç–∞–≤–ª–µ–Ω –¥–ª—è –ø–æ–ª–Ω–æ—Ç—ã) ...
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    asyncio.run(main())