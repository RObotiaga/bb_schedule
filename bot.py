import asyncio
import logging
import json
import os
import re
import sys
from datetime import date, timedelta

from aiogram import Bot, Dispatcher, F, types
from aiogram.filters import CommandStart, BaseFilter
from aiogram.types import Message, CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import InlineKeyboardBuilder

# --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", 'placeholder:TELEGRAM_TOKEN_REMOVED')
SCHEDULE_JSON_PATH = "schedule.json"
ADMIN_ID = 936853523

USER_DATA_JSON_PATH = "user_data.json"

# --- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö ---
full_schedule = {}
structured_data = {}
FACULTIES_LIST = []
user_choices = {}

# --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö ---
def load_user_data():
    global user_choices
    if os.path.exists(USER_DATA_JSON_PATH):
        try:
            with open(USER_DATA_JSON_PATH, 'r', encoding='utf-8') as f:
                user_choices = json.load(f)
                user_choices = {int(k): v for k, v in user_choices.items()}
        except (json.JSONDecodeError, TypeError):
            logging.error("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è user_data.json. –ë—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π.")
            user_choices = {}
    else:
        user_choices = {}
    logging.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(user_choices)} –∑–∞–ø–∏—Å–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.")

def save_user_data(user_id: int, group: str | None):
    if group is None:
        user_choices.pop(user_id, None) # –£–¥–∞–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –µ—Å–ª–∏ –≥—Ä—É–ø–ø–∞ None
    else:
        user_choices[user_id] = group
    with open(USER_DATA_JSON_PATH, 'w', encoding='utf-8') as f:
        json.dump(user_choices, f, ensure_ascii=False, indent=4)

def get_user_group(user_id: int) -> str | None:
    return user_choices.get(user_id)

def load_and_prepare_data():
    global full_schedule, structured_data, FACULTIES_LIST
    if not os.path.exists(SCHEDULE_JSON_PATH):
        logging.warning(f"–§–∞–π–ª '{SCHEDULE_JSON_PATH}' –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return False
    try:
        with open(SCHEDULE_JSON_PATH, 'r', encoding='utf-8') as f:
            full_schedule = json.load(f)
    except json.JSONDecodeError:
        logging.error(f"–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON –≤ {SCHEDULE_JSON_PATH}.")
        return False
    
    temp_structured_data = {}
    for group_name, group_schedule in full_schedule.items():
        if not group_schedule: continue
        try:
            first_date = next(iter(group_schedule))
            first_lesson = group_schedule[first_date][0]
            faculty, course = first_lesson['faculty'], first_lesson['course']
            if faculty not in temp_structured_data: temp_structured_data[faculty] = {}
            if course not in temp_structured_data[faculty]: temp_structured_data[faculty][course] = []
            if group_name not in temp_structured_data[faculty][course]: temp_structured_data[faculty][course].append(group_name)
        except (StopIteration, IndexError, KeyError) as e:
            logging.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≥—Ä—É–ø–ø—É '{group_name}'. –û—à–∏–±–∫–∞: {e}")
    
    structured_data = temp_structured_data
    FACULTIES_LIST = sorted(structured_data.keys())
    logging.info("–î–∞–Ω–Ω—ã–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.")
    return True

load_and_prepare_data()
load_user_data()

# --- –§–∏–ª—å—Ç—Ä –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ ---
class IsAdmin(BaseFilter):
    async def __call__(self, message: Message) -> bool:
        return message.from_user.id == ADMIN_ID

# --- –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã ---
def get_faculties_keyboard():
    builder = InlineKeyboardBuilder()
    for index, faculty_name in enumerate(FACULTIES_LIST):
        builder.button(text=faculty_name, callback_data=f"faculty:{index}")
    builder.adjust(2)
    return builder.as_markup()

def get_courses_keyboard(faculty: str):
    builder = InlineKeyboardBuilder()
    courses = sorted(structured_data.get(faculty, {}).keys(), key=lambda c: int(c) if c.isdigit() else 99)
    for course in courses:
        builder.button(text=f"{course} –∫—É—Ä—Å", callback_data=f"course:{faculty}:{course}")
    builder.adjust(2)
    builder.row(InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Ñ–∞–∫—É–ª—å—Ç–µ—Ç–∞–º", callback_data="back_to_faculties"))
    return builder.as_markup()

def get_groups_keyboard(faculty: str, course: str):
    builder = InlineKeyboardBuilder()
    groups = sorted(structured_data.get(faculty, {}).get(course, []))
    for group in groups:
        builder.button(text=group, callback_data=f"group:{group}")
    builder.adjust(2)
    faculty_index = FACULTIES_LIST.index(faculty)
    builder.row(InlineKeyboardButton(text=f"‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –∫—É—Ä—Å–∞–º ({faculty})", callback_data=f"back_to_courses:{faculty_index}"))
    return builder.as_markup()

day_selection_keyboard = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–°–µ–≥–æ–¥–Ω—è"), KeyboardButton(text="–ó–∞–≤—Ç—Ä–∞")], [KeyboardButton(text="–ü–Ω"), KeyboardButton(text="–í—Ç"), KeyboardButton(text="–°—Ä")], [KeyboardButton(text="–ß—Ç"), KeyboardButton(text="–ü—Ç"), KeyboardButton(text="–°–±")], [KeyboardButton(text="/start")]], resize_keyboard=True)
admin_keyboard = ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ"), KeyboardButton(text="üì• –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å JSON")], [KeyboardButton(text="‚¨ÖÔ∏è –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏")]], resize_keyboard=True)

# --- –•—ç–Ω–¥–ª–µ—Ä—ã ---
dp = Dispatcher()

@dp.message(CommandStart())
async def send_welcome(message: Message):
    save_user_data(message.from_user.id, None)
    await message.answer("üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –Ø –ø–æ–º–æ–≥—É –≤–∞–º —É–∑–Ω–∞—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ.\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —Ñ–∞–∫—É–ª—å—Ç–µ—Ç:", reply_markup=get_faculties_keyboard())
    
@dp.message(F.text == "/admin", IsAdmin())
async def admin_panel(message: Message):
    await message.answer("–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å!", reply_markup=admin_keyboard)

@dp.message(F.text == "‚¨ÖÔ∏è –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏", IsAdmin())
async def exit_admin_panel(message: Message):
    await message.answer("–í—ã –≤—ã—à–ª–∏ –∏–∑ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.", reply_markup=day_selection_keyboard)

async def run_script(command: list, message: Message):
    process = await asyncio.create_subprocess_exec(*command, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
    stdout, stderr = await process.communicate()
    if process.returncode != 0:
        error_message = f"‚ùå –û—à–∏–±–∫–∞ `{command[-1]}`:\n`{stderr.decode('utf-8', errors='ignore')}`"
        await message.answer(error_message[:4096], parse_mode="Markdown"); return False
    return True

@dp.message(F.text == "üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ", IsAdmin())
async def update_schedule(message: Message):
    await message.answer("üöÄ –ù–∞—á–∏–Ω–∞—é –ø–æ–ª–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ...", reply_markup=types.ReplyKeyboardRemove())
    python_executable = sys.executable
    if await run_script([python_executable, "fetch_schedule.py"], message) and \
       await run_script([python_executable, "process_schedules.py"], message) and \
       load_and_prepare_data():
        await message.answer("‚úÖ –ü–æ–ª–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!", reply_markup=admin_keyboard)
    else:
        await message.answer("‚ùóÔ∏è–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–µ—Ä–≤–∞–Ω–æ –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏.", reply_markup=admin_keyboard)

@dp.message(F.text == "üì• –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å JSON", IsAdmin())
async def reload_from_json(message: Message):
    await message.answer("–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞—é –¥–∞–Ω–Ω—ã–µ –∏–∑ `schedule.json`...", parse_mode="Markdown")
    if load_and_prepare_data():
        await message.answer("‚úÖ –î–∞–Ω–Ω—ã–µ –≤ –±–æ—Ç–µ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã!", reply_markup=admin_keyboard)
    else:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ.", reply_markup=admin_keyboard)

@dp.callback_query(F.data.startswith("faculty:"))
async def process_faculty_choice(callback: CallbackQuery):
    faculty_index = int(callback.data.split(":")[1])
    faculty_name = FACULTIES_LIST[faculty_index]
    await callback.message.edit_text(f"–í—ã –≤—ã–±—Ä–∞–ª–∏: *{faculty_name}*.\n\n–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å:", reply_markup=get_courses_keyboard(faculty_name), parse_mode="Markdown")
    await callback.answer()

@dp.callback_query(F.data.startswith("course:"))
async def process_course_choice(callback: CallbackQuery):
    _, faculty, course = callback.data.split(":")
    await callback.message.edit_text(f"–§–∞–∫—É–ª—å—Ç–µ—Ç: *{faculty}*, –ö—É—Ä—Å: *{course}*.\n\n–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à—É –≥—Ä—É–ø–ø—É:", reply_markup=get_groups_keyboard(faculty, course), parse_mode="Markdown")
    await callback.answer()

@dp.callback_query(F.data.startswith("group:"))
async def process_group_choice(callback: CallbackQuery):
    group = callback.data.split(":")[1]
    save_user_data(callback.from_user.id, group)
    await callback.message.delete()
    await callback.message.answer(f"–û—Ç–ª–∏—á–Ω–æ! –í–∞—à–∞ –≥—Ä—É–ø–ø–∞ *{group}* —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞.\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è.", reply_markup=day_selection_keyboard, parse_mode="Markdown")
    await callback.answer()

@dp.callback_query(F.data == "back_to_faculties")
async def back_to_faculties(callback: CallbackQuery):
    await callback.message.edit_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à —Ñ–∞–∫—É–ª—å—Ç–µ—Ç:", reply_markup=get_faculties_keyboard())
    await callback.answer()

@dp.callback_query(F.data.startswith("back_to_courses:"))
async def back_to_courses(callback: CallbackQuery):
    faculty_index = int(callback.data.split(":")[1])
    faculty_name = FACULTIES_LIST[faculty_index]
    await callback.message.edit_text(f"–í—ã –≤—ã–±—Ä–∞–ª–∏: *{faculty_name}*.\n\n–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ –∫—É—Ä—Å:", reply_markup=get_courses_keyboard(faculty_name), parse_mode="Markdown")
    await callback.answer()

def get_date_by_day_name(day_name: str) -> date:
    today = date.today()
    if day_name == "–°–µ–≥–æ–¥–Ω—è": return today
    if day_name == "–ó–∞–≤—Ç—Ä–∞": return today + timedelta(days=1)
    days_map = {"–ü–Ω": 0, "–í—Ç": 1, "–°—Ä": 2, "–ß—Ç": 3, "–ü—Ç": 4, "–°–±": 5}
    target_weekday = days_map[day_name]
    days_ahead = target_weekday - today.weekday()
    if days_ahead < 0: days_ahead += 7
    return today + timedelta(days=days_ahead)

def format_schedule_message(group: str, target_date: date, lessons: list) -> str:
    if not lessons: return f"–ù–∞ *{target_date.strftime('%d %B')}* –¥–ª—è –≥—Ä—É–ø–ø—ã *{group}* –ø–∞—Ä –Ω–µ—Ç."
    week_type = lessons[0]['week_type'].capitalize()
    months = ["–Ø–Ω–≤–∞—Ä—è", "–§–µ–≤—Ä–∞–ª—è", "–ú–∞—Ä—Ç–∞", "–ê–ø—Ä–µ–ª—è", "–ú–∞—è", "–ò—é–Ω—è", "–ò—é–ª—è", "–ê–≤–≥—É—Å—Ç–∞", "–°–µ–Ω—Ç—è–±—Ä—è", "–û–∫—Ç—è–±—Ä—è", "–ù–æ—è–±—Ä—è", "–î–µ–∫–∞–±—Ä—è"]
    weekdays = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    date_str = f"{weekdays[target_date.weekday()]} {target_date.day} {months[target_date.month - 1]}"
    header = f"*{week_type} –Ω–µ–¥–µ–ª—è*\n*{group}*\n\n*{date_str}*"
    lesson_parts = [f"‚è∞ {lesson['time']}\n-  {lesson['subject']}\n-  {lesson['teacher']}\n-  {lesson['location']}" for lesson in lessons]
    return f"{header}\n\n" + "\n\n".join(lesson_parts)

@dp.message(F.text.in_({"–°–µ–≥–æ–¥–Ω—è", "–ó–∞–≤—Ç—Ä–∞", "–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±"}))
async def send_schedule(message: Message):
    group = get_user_group(message.from_user.id)
    if not group:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –≥—Ä—É–ø–ø—É —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /start")
        return
    try:
        target_date = get_date_by_day_name(message.text)
        date_str = target_date.strftime('%Y-%m-%d')
        lessons = full_schedule.get(group, {}).get(date_str, [])
        response_text = format_schedule_message(group, target_date, lessons)
        await message.answer(response_text, parse_mode="Markdown")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: {e}")
        await message.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞.")

async def main():
    bot = Bot(token=BOT_TOKEN)
    await dp.start_polling(bot)

# --- –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ë–õ–û–ö ---
if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    asyncio.run(main())